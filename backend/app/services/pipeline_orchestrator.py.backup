# backend/app/services/pipeline_orchestrator.py - FIXED
"""
Pipeline Orchestrator - Works with LeadICPAssignment architecture
Processes one raw_lead against multiple ICPs, creating assignments for each

FIXED: Removed stage_updated_at (tracked in LeadStageActivity instead)
"""

from typing import Optional, Dict, Any, List
from datetime import datetime
from decimal import Decimal
import logging

from sqlalchemy.orm import Session
from sqlalchemy import and_

from app.models import (
    Lead,
    LeadICPAssignment,
    RawLead,
    ICP,
    LeadRejectionTracking
)
from app.services.icp_scoring_engine import ICPScoringEngine
from app.services.activity_logger import ActivityLogger
from app.services.enrichment_service import create_enrichment_service

logger = logging.getLogger(__name__)


class PipelineOrchestrator:
    """
    Orchestrates complete lead processing pipeline using assignments
    
    Flow:
    1. Create/Find Lead (one record, no icp_id)
    2. Create LeadICPAssignment
    3. Score â†’ Enrich â†’ Verify â†’ Auto-Qualify (all tracked in assignment)
    """
    
    def __init__(self, db: Session):
        self.db = db
        self.scoring_engine = ICPScoringEngine(db)
        self.activity_logger = ActivityLogger(db)
    
    async def process_raw_lead(
        self,
        raw_lead: RawLead,
        icp: ICP,
        job_id: Optional[str] = None,
        stages_to_run: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Process raw lead for a specific ICP
        
        Creates/finds Lead, creates Assignment, runs through pipeline
        
        Args:
            raw_lead: RawLead from scraper
            icp: ICP to score against
            job_id: Optional processing job ID
            stages_to_run: Optional list of stages (default: all)
            
        Returns:
            Processing result with assignment_id and status
        """
        start_time = datetime.utcnow()
        
        try:
            # Step 1: Create or find lead (no icp_id)
            lead, is_new = await self._create_or_find_lead(raw_lead)
            
            # Step 2: Check for existing assignment
            assignment = await self._get_or_create_assignment(lead, icp, job_id)
            
            if not is_new and not stages_to_run:
                logger.info(f"Lead {lead.id} already processed for ICP {icp.id}, skipping")
                return {
                    "success": True,
                    "lead_id": str(lead.id),
                    "assignment_id": str(assignment.id),
                    "status": assignment.status,
                    "skipped": True
                }
            
            # Step 3: Run pipeline stages
            result = await self._run_pipeline_stages(
                lead=lead,
                assignment=assignment,
                raw_lead=raw_lead,
                icp=icp,
                job_id=job_id,
                stages_to_run=stages_to_run
            )
            
            # Update raw lead tracking
            await self._update_raw_lead_tracking(raw_lead, icp, lead)
            
            elapsed = (datetime.utcnow() - start_time).total_seconds()
            logger.info(
                f"Processed lead {lead.id} for ICP {icp.name}: "
                f"status={assignment.status}, score={assignment.fit_score_percentage}, "
                f"time={elapsed:.2f}s"
            )
            
            return {
                "success": True,
                "lead_id": str(lead.id),
                "assignment_id": str(assignment.id),
                "status": assignment.status,
                "score": assignment.fit_score_percentage,
                "processing_time_seconds": elapsed,
                **result
            }
        
        except Exception as e:
            logger.error(f"Pipeline error for raw_lead {raw_lead.id}, ICP {icp.id}: {e}")
            return {
                "success": False,
                "error": str(e),
                "lead_id": None,
                "assignment_id": None
            }
    
    async def _create_or_find_lead(self, raw_lead: RawLead) -> tuple[Lead, bool]:
        """
        Create new lead or find existing by email
        NO icp_id on lead - assignments handle that
        """
        # Check for duplicate by email
        existing = self.db.query(Lead).filter(
            and_(
                Lead.email == raw_lead.email,
                Lead.tenant_id == raw_lead.tenant_id
            )
        ).first()
        
        if existing:
            return existing, False
        
        # Create new lead
        lead = Lead(
            tenant_id=raw_lead.tenant_id,
            raw_lead_id=raw_lead.id,
            email=raw_lead.email,
            first_name=raw_lead.first_name,
            last_name=raw_lead.last_name,
            phone=raw_lead.phone,
            job_title=raw_lead.job_title,
            linkedin_url=raw_lead.linkedin_url,
            company_name=raw_lead.company_name,
            company_domain=raw_lead.company_domain,
            company_website=raw_lead.company_website,
            company_size=raw_lead.company_size,
            company_industry=raw_lead.company_industry,
            city=raw_lead.city,
            state=raw_lead.state,
            country=raw_lead.country,
            source=raw_lead.source_name,
            source_url=raw_lead.source_url,
            processing_started_at=datetime.utcnow()
        )
        
        self.db.add(lead)
        self.db.flush()  # Get ID without committing
        
        logger.info(f"Created lead {lead.id} from raw_lead {raw_lead.id}")
        
        return lead, True
    
    async def _get_or_create_assignment(
        self,
        lead: Lead,
        icp: ICP,
        job_id: Optional[str]
    ) -> LeadICPAssignment:
        """
        Get existing assignment or create new one
        """
        # Check for existing assignment
        assignment = self.db.query(LeadICPAssignment).filter(
            and_(
                LeadICPAssignment.lead_id == lead.id,
                LeadICPAssignment.icp_id == icp.id
            )
        ).first()
        
        if assignment:
            return assignment
        
        # Create new assignment
        # âœ… FIXED: Removed stage_updated_at (tracked in LeadStageActivity)
        assignment = LeadICPAssignment(
            lead_id=lead.id,
            icp_id=icp.id,
            tenant_id=lead.tenant_id,
            status='new',
            bucket='new',
            processing_job_id=job_id
            # stage_updated_at removed - use LeadStageActivity.timestamp instead
        )
        
        self.db.add(assignment)
        self.db.flush()
        
        # Log creation (this updates LeadStageActivity with timestamp)
        self.activity_logger.log_stage_transition(
            lead_id=str(lead.id),
            tenant_id=str(lead.tenant_id),
            icp_id=str(icp.id),
            assignment_id=str(assignment.id),
            from_stage=None,
            to_stage="new",
            reason="assignment_created",
            details={"job_id": job_id} if job_id else {}
        )
        
        logger.info(f"Created assignment {assignment.id} for lead {lead.id}, ICP {icp.id}")
        
        return assignment
    
    async def _run_pipeline_stages(
        self,
        lead: Lead,
        assignment: LeadICPAssignment,
        raw_lead: RawLead,
        icp: ICP,
        job_id: Optional[str],
        stages_to_run: Optional[List[str]]
    ) -> Dict[str, Any]:
        """
        Run pipeline stages
        
        Stages: score â†’ enrich â†’ verify â†’ qualify
        """
        result = {}
        
        # Default: run all stages
        if not stages_to_run:
            stages_to_run = ['score', 'enrich', 'verify', 'qualify']
        
        # Stage 1: Scoring
        if 'score' in stages_to_run:
            score_result = await self._score_assignment(assignment, raw_lead, icp, job_id)
            result['scoring'] = score_result
            
            # Check auto-reject
            if score_result.get('rejected'):
                return result
        
        # Stage 2: Enrichment
        if 'enrich' in stages_to_run and icp.enrichment_enabled:
            enrich_result = await self._enrich_lead(lead, assignment, icp, job_id)
            result['enrichment'] = enrich_result
        
        # Stage 3: Verification
        if 'verify' in stages_to_run and icp.verification_enabled:
            verify_result = await self._verify_lead(lead, assignment, icp, job_id)
            result['verification'] = verify_result
        
        # Stage 4: Auto-qualification
        if 'qualify' in stages_to_run:
            qualify_result = await self._auto_qualify(lead, assignment, icp, job_id)
            result['qualification'] = qualify_result
        
        # Mark processing complete
        lead.processing_completed_at = datetime.utcnow()
        self.db.commit()
        
        return result
    
    async def _score_assignment(
        self,
        assignment: LeadICPAssignment,
        raw_lead: RawLead,
        icp: ICP,
        job_id: Optional[str]
    ) -> Dict[str, Any]:
        """
        Score lead against ICP - update assignment
        """
        start_time = datetime.utcnow()
        
        # Score the lead
        score_result = await self.scoring_engine.score_lead(raw_lead, icp)
        
        # Update assignment
        assignment.fit_score = score_result.score
        assignment.fit_score_percentage = score_result.score
        assignment.icp_score_confidence = score_result.confidence  # âœ… This column will be added to DB
        assignment.scoring_details = score_result.breakdown
        assignment.update_status('scored')
        
        self.db.commit()
        
        processing_time = self._elapsed_ms(start_time)
        
        # Log scoring
        self.activity_logger.log_scoring(
            lead_id=str(assignment.lead_id),
            tenant_id=str(assignment.tenant_id),
            icp_id=str(icp.id),
            assignment_id=str(assignment.id),
            score=score_result.score,
            confidence=score_result.confidence,
            breakdown=score_result.breakdown,
            job_id=job_id,
            processing_time_ms=processing_time
        )
        
        # Check auto-reject threshold
        if score_result.score < float(icp.auto_reject_threshold or 30):
            await self._reject_assignment(
                assignment=assignment,
                icp=icp,
                reason="auto_rejected_low_score",
                details=f"Score {score_result.score} below threshold {icp.auto_reject_threshold}",
                job_id=job_id
            )
            return {"rejected": True, "reason": "low_score"}
        
        logger.info(
            f"Scored assignment {assignment.id}: score={score_result.score}, "
            f"confidence={score_result.confidence}"
        )
        
        return {
            "score": score_result.score,
            "confidence": score_result.confidence,
            "rejected": False
        }
    
    async def _enrich_lead(
        self,
        lead: Lead,
        assignment: LeadICPAssignment,
        icp: ICP,
        job_id: Optional[str]
    ) -> Dict[str, Any]:
        """
        Enrich lead data - updates lead record, tracks in assignment
        """
        start_time = datetime.utcnow()
        
        # Create enrichment service
        enrichment_service = create_enrichment_service(self.db)
        
        # Enrich with ICP-specific config
        result = await enrichment_service.enrich_lead_with_icp_config(
            email=lead.email,
            company_domain=lead.company_domain,
            company_name=lead.company_name,
            tenant_id=str(lead.tenant_id),
            icp_id=str(icp.id)
        )
        
        processing_time = self._elapsed_ms(start_time)
        
        if result.success and result.enriched_data:
            # Update lead with enriched data
            if "company_description" in result.enriched_data:
                lead.company_description = result.enriched_data["company_description"]
            
            if "company_tech_stack" in result.enriched_data:
                if not lead.enrichment_data:
                    lead.enrichment_data = {}
                lead.enrichment_data["tech_stack"] = result.enriched_data["company_tech_stack"]
            
            if "company_employee_count" in result.enriched_data:
                lead.company_employee_count = result.enriched_data["company_employee_count"]
            
            # Store full enrichment data
            if not lead.enrichment_data:
                lead.enrichment_data = {}
            lead.enrichment_data.update(result.enriched_data)
            
            lead.enrichment_completeness = len(result.fields_added)
            
            # Update assignment status
            assignment.update_status('enriched')
            self.db.commit()
            
            # Log enrichment
            self.activity_logger.log_enrichment(
                lead_id=str(lead.id),
                tenant_id=str(lead.tenant_id),
                icp_id=str(icp.id),
                assignment_id=str(assignment.id),
                fields_added=result.fields_added,
                cache_hit=result.cache_hit,
                cost=result.cost,
                job_id=job_id,
                processing_time_ms=processing_time

            )
            
            logger.info(
                f"Enriched lead {lead.id}: {len(result.fields_added)} fields, "
                f"cost=${result.cost:.4f}"
            )
        
        return {
            "success": result.success,
            "fields_added": len(result.fields_added),
            "cost": result.cost
        }
    
    # backend/app/services/pipeline_orchestrator.py - UPDATE _verify_lead method

    async def _verify_lead(
        self,
        lead: Lead,
        assignment: LeadICPAssignment,
        icp: ICP,
        job_id: Optional[str]
    ) -> Dict[str, Any]:
        """
        âœ… 3-Pass Email Verification with Field-Level Confidence
        
        Pass 1: Syntax validation (FREE, instant)
        Pass 2: Domain/MX validation (FREE, ~1-2s)
        Pass 3: Mailbox validation (PAID, ~20-60s)
        """
        start_time = datetime.utcnow()
        
        logger.info(f"Starting 3-pass verification for: {lead.email}")
        
        try:
            # Create 3-pass verification service
            verifier = create_verification_service()
            
            # Run complete 3-pass verification
            result = await verifier.verify_email(lead.email)
            
            # Update lead with comprehensive results
            lead.email_verified = result.is_valid
            lead.email_verification_status = result.overall_status
            lead.email_verification_confidence = Decimal(str(result.overall_confidence))
            
            # Store detailed verification data with all pass results
            if not hasattr(lead, 'verification_data') or lead.verification_data is None:
                lead.verification_data = {}
            
            lead.verification_data.update({
                "verification_timestamp": datetime.utcnow().isoformat(),
                "provider": result.provider,
                "passes_completed": result.passes_completed,
                
                # Overall scores
                "overall_confidence": result.overall_confidence,
                "deliverability_score": result.deliverability_score,
                
                # Field-level scores
                "syntax_score": result.syntax_score,
                "domain_score": result.domain_score,
                "mailbox_score": result.mailbox_score,
                
                # Metadata
                "is_disposable": result.is_disposable,
                "is_role_account": result.is_role_account,
                "is_free_provider": result.is_free_provider,
                "is_catch_all": result.is_catch_all,
                
                # Pass details
                "pass_1_details": result.pass_1_result.to_dict() if result.pass_1_result else None,
                "pass_2_details": result.pass_2_result.to_dict() if result.pass_2_result else None,
                "pass_3_details": result.pass_3_result.to_dict() if result.pass_3_result else None,
                
                # Full details
                "all_details": result.details
            })
            
            # Update assignment
            assignment.update_status('verified')
            self.db.commit()
            
            processing_time = self._elapsed_ms(start_time)
            
            # âœ… Log verification to activity (includes all details)
            self.activity_logger.log_verification(
                lead_id=str(lead.id),
                tenant_id=str(lead.tenant_id),
                icp_id=str(icp.id),
                assignment_id=str(assignment.id),
                verification_status=result.overall_status,
                confidence=result.overall_confidence,
                cost=result.total_cost,
                cache_hit=False,
                job_id=job_id,
                processing_time_ms=processing_time
            )
            
            logger.info(
                f"âœ… Verification complete for {lead.email}:\n"
                f"   Status: {result.overall_status}\n"
                f"   Confidence: {result.overall_confidence}%\n"
                f"   Passes: {result.passes_completed}/3\n"
                f"   Cost: ${result.total_cost:.4f}\n"
                f"   Time: {result.total_time_ms}ms"
            )
            
            return {
                "verified": result.is_valid,
                "status": result.overall_status,
                "confidence": result.overall_confidence,
                "passes_completed": result.passes_completed,
                "field_scores": {
                    "syntax": result.syntax_score,
                    "domain": result.domain_score,
                    "mailbox": result.mailbox_score,
                    "deliverability": result.deliverability_score
                },
                "metadata": {
                    "is_disposable": result.is_disposable,
                    "is_role": result.is_role_account,
                    "is_free": result.is_free_provider,
                    "is_catch_all": result.is_catch_all
                },
                "cost": result.total_cost,
                "time_ms": result.total_time_ms,
                "error": result.error
            }
        
        except Exception as e:
            logger.error(f"âŒ Verification error for {lead.email}: {e}")
            
            # Log failure to activity
            self.activity_logger.log_verification(
                lead_id=str(lead.id),
                tenant_id=str(lead.tenant_id),
                icp_id=str(icp.id),
                assignment_id=str(assignment.id),
                verification_status="error",
                confidence=0.0,
                cost=0.0,
                cache_hit=False,
                job_id=job_id,
                processing_time_ms=self._elapsed_ms(start_time)
            )
            
            # Return error result
            return {
                "verified": False,
                "status": "error",
                "confidence": 0.0,
                "error": str(e),
                "cost": 0.0
            }
    
    async def _auto_qualify(
        self,
        lead: Lead,
        assignment: LeadICPAssignment,
        icp: ICP,
        job_id: Optional[str]
    ) -> Dict[str, Any]:
        """
        Auto-qualify lead based on score and verification
        
        Rules:
        - Score >= auto_approve_threshold AND verified â†’ qualified
        - Score >= review_threshold â†’ pending_review
        - Score < review_threshold â†’ rejected (already handled in scoring)
        """
        score = assignment.fit_score_percentage or 0.0
        verified = lead.email_verified
        
        # Auto-approve: high score + verified email
        if score >= float(icp.auto_approve_threshold or 80) and verified:
            assignment.update_status('qualified')
            assignment.qualified_at = datetime.utcnow()
            self.db.commit()
            
            self.activity_logger.log_qualification(
                lead_id=str(lead.id),
                tenant_id=str(lead.tenant_id),
                icp_id=str(icp.id),
                assignment_id=str(assignment.id),
                decision="auto_approved",
                reason=f"Score {score}% >= {icp.auto_approve_threshold}% and verified",
                score=score,
                job_id=job_id
            )
            
            logger.info(f"âœ… Auto-qualified assignment {assignment.id}: score={score}%, verified={verified}")
            
            return {
                "decision": "auto_approved",
                "reason": "High score and verified email",
                "score": score
            }
        
        # Review needed: moderate score or not verified
        elif score >= float(icp.review_threshold or 50):
            assignment.update_status('pending_review')
            self.db.commit()
            
            self.activity_logger.log_qualification(
                lead_id=str(lead.id),
                tenant_id=str(lead.tenant_id),
                icp_id=str(icp.id),
                assignment_id=str(assignment.id),
                decision="pending_review",
                reason=f"Score {score}% requires manual review",
                score=score,
                job_id=job_id
            )
            
            logger.info(f"ðŸ“‹ Pending review: {assignment.id}, score={score}%, verified={verified}")
            
            return {
                "decision": "pending_review",
                "reason": "Requires manual review",
                "score": score
            }
        
        else:
            # Already rejected in scoring stage
            return {
                "decision": "rejected",
                "reason": "Low score",
                "score": score
            }
            
    async def _reject_assignment(
        self,
        assignment: LeadICPAssignment,
        icp: ICP,
        reason: str,
        details: str,
        job_id: Optional[str]
    ):
        """
        Reject assignment with tracking
        """
        # Update assignment
        assignment.update_status('rejected')
        self.db.commit()
        
        # Create rejection record
        rejection = LeadRejectionTracking(
            lead_id=assignment.lead_id,
            icp_id=icp.id,
            assignment_id=assignment.id,
            tenant_id=assignment.tenant_id,
            rejection_stage=assignment.status,
            rejection_reason=reason,
            rejection_category="low_score",
            rejection_details=details,
            can_be_overridden=True,
            rejected_at=datetime.utcnow()
        )
        
        self.db.add(rejection)
        self.db.commit()
        
        # Log rejection
        self.activity_logger.log_rejection(
            lead_id=str(assignment.lead_id),
            tenant_id=str(assignment.tenant_id),
            icp_id=str(icp.id),
            assignment_id=str(assignment.id),
            reason=reason,
            details=details,
            job_id=job_id
        )
    
    async def _update_raw_lead_tracking(
        self,
        raw_lead: RawLead,
        icp: ICP,
        lead: Lead
    ):
        """
        Update raw lead tracking
        """
        # Add ICP to processed list
        if not raw_lead.processed_by_icps:
            raw_lead.processed_by_icps = []
        
        if str(icp.id) not in raw_lead.processed_by_icps:
            raw_lead.processed_by_icps = raw_lead.processed_by_icps + [str(icp.id)]
        
        # Link to lead if not already linked
        if not raw_lead.lead_id:
            raw_lead.lead_id = lead.id
            raw_lead.processed_at = datetime.utcnow()
        
        # Check if all ICPs processed
        active_icps = self.db.query(ICP).filter(
            ICP.tenant_id == raw_lead.tenant_id,
            ICP.is_active == True
        ).count()
        
        if len(raw_lead.processed_by_icps) >= active_icps:
            raw_lead.processing_status = "processed"
        
        self.db.commit()
    
    def _elapsed_ms(self, start_time: datetime) -> int:
        """Calculate elapsed milliseconds"""
        return int((datetime.utcnow() - start_time).total_seconds() * 1000)